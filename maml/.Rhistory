httpheader=c('Content-Type' = "application/json", 'Authorization' = authz_hdr),
postfields=body,
writefunction = h$update,
headerfunction = hdr$update,
verbose = TRUE,
ssl.verifypeer = FALSE,
ssl.verifyhost = FALSE
)
headers = hdr$value()
httpStatus = headers["status"]
if (httpStatus >= 400)
{
print(paste("The request failed with status code:", httpStatus, sep=" "))
# Print the headers - they include the request ID and the timestamp, which are useful for debugging the failure
print("headers:")
print(headers)
}
#  result = fromJSON(h$value())
return(result)
}
result <- consumeSingleRequest(endpoint[[1]]["PrimaryKey"], paste(endpoint[[1]]["ApiLocation"],"/execute?api-version=2.0&details=true",sep=""), list("icol1"), list(1))
results
result
fromJSON(result)
typeof(result)
typeof(fromJSON(result))
consumeSingleRequest <- function(api_key, URL, columnNames, ...) {
# Accept SSL certificates issued by public Certificate Authorities
values = output_list <- lapply(X=list(...), function(x) x)
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
h = basicTextGatherer()
hdr = basicHeaderGatherer()
req = list(
Inputs = list(
input1 = list(
ColumnNames = columnNames,
Values = values
)
)
)
body = enc2utf8(toJSON(req))
print(body)
print(api_key)
authz_hdr = paste('Bearer', api_key, sep=' ')
h$reset()
curlPerform(url = URL,
httpheader=c('Content-Type' = "application/json", 'Authorization' = authz_hdr),
postfields=body,
writefunction = h$update,
headerfunction = hdr$update,
verbose = TRUE,
ssl.verifypeer = FALSE,
ssl.verifyhost = FALSE
)
headers = hdr$value()
httpStatus = headers["status"]
if (httpStatus >= 400)
{
print(paste("The request failed with status code:", httpStatus, sep=" "))
# Print the headers - they include the request ID and the timestamp, which are useful for debugging the failure
print("headers:")
print(headers)
}
result = fromJSON(h$value())
return(result)
}
typeof(fromJSON(result))
typeof(fromJSON(result)$Results)
result <- fromJSON(result)
result$Results
result$Results$output1
result$Results$output1$value$Values
typeof(result$Results$output1$value$Values)
consumeSingleRequest <- function(api_key, URL, columnNames, ...) {
# Accept SSL certificates issued by public Certificate Authorities
values = output_list <- lapply(X=list(...), function(x) x)
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
h = basicTextGatherer()
hdr = basicHeaderGatherer()
req = list(
Inputs = list(
input1 = list(
ColumnNames = columnNames,
Values = values
)
)
)
body = enc2utf8(toJSON(req))
print(body)
print(api_key)
authz_hdr = paste('Bearer', api_key, sep=' ')
h$reset()
curlPerform(url = URL,
httpheader=c('Content-Type' = "application/json", 'Authorization' = authz_hdr),
postfields=body,
writefunction = h$update,
headerfunction = hdr$update,
verbose = TRUE,
ssl.verifypeer = FALSE,
ssl.verifyhost = FALSE
)
headers = hdr$value()
httpStatus = headers["status"]
if (httpStatus >= 400)
{
print(paste("The request failed with status code:", httpStatus, sep=" "))
# Print the headers - they include the request ID and the timestamp, which are useful for debugging the failure
print("headers:")
print(headers)
}
result = fromJSON(h$value())
return(result)
}
typeof(result$Results$output1$value$Values)
?jsonlite::serializeJSON
library(jsonlite)
serializeJSON(6)
typeof(unserializeJSON(serializeJSON(6)))
add2 <- function(a,b) {}
add2 <- function(a,b) {
return(a+b)
}
add2(5)
install.packages('functional')
library(functional)
?curry
?Curry
Curry(add2, 5)
add2c <- Curry(add2, 5)
add2c
add2c(4)
data.frame(list(1,2))
serializeJSON(data.frame(list(1,2)))
unserializeJSON(serializeJSON(data.frame(list(1,2))))
unserializeJSON(serializeJSON(data.frame(list(a,2))))
serializeJSON(data.frame(list(a,2)))
?lm
lm.D90
?predict
predict(lm,.D90, 5)
predict(lm.D90, 5)
predict(lm.D90)
lm.D90
w <- 1 + x^2
fit <- lm(y ~ x)
x <- rnorm(15)
y <- x + rnorm(15)
predict(lm(y ~ x))
predict.lm(lm.D90, 1)
2
3
4
5
test <- read.csv(file="test.csv")
train <- read.csv(file="train.csv")
head(test)
head(train)
#y variable
survived <- train$Survived
#id
passengerId <- test$PassengerId
#remove from the training sample
train = train[,-2]
end_trn = nrow(train)
#combine the two sets
train <- rbind(train, test)
#Age replace with mean
train$Age[is.na(train$Age)] <- 30
end = nrow(train)
#remove columns
train = train[,c(-1,-3,-8,-10,-11)]
head(train)
library(gbm)
set.seed(123)
pr=0
tr=0
n.models = 5
ntrees=2000
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
tr1 = predict(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
test <- read.csv(file="test.csv")
train <- read.csv(file="train.csv")
head(test)
head(train)
#y variable
survived <- train$Survived
#id
passengerId <- test$PassengerId
#remove from the training sample
train = train[,-2]
end_trn = nrow(train)
#combine the two sets
train <- rbind(train, test)
#Age replace with mean
train$Age[is.na(train$Age)] <- 30
end = nrow(train)
#remove columns
train = train[,c(-1,-3,-8,-10,-11)]
head(train)
library(gbm)
set.seed(123)
pr=0
tr=0
n.models = 5
ntrees=2000
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
tr1 = predict(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
library(gbm)
??gbm
install.packages("gbm")
getwd()
setwd("C:/Users/t-alewa/Downloads")
setwd()
getwd()
test <- read.csv(file="test.csv")
train <- read.csv(file="train.csv")
head(test)
head(train)
#y variable
survived <- train$Survived
#id
passengerId <- test$PassengerId
#remove from the training sample
train = train[,-2]
end_trn = nrow(train)
#combine the two sets
train <- rbind(train, test)
#Age replace with mean
train$Age[is.na(train$Age)] <- 30
end = nrow(train)
#remove columns
train = train[,c(-1,-3,-8,-10,-11)]
head(train)
library(gbm)
set.seed(123)
pr=0
tr=0
n.models = 5
ntrees=2000
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
tr1 = predict(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
library(gbm)
set.seed(123)
pr=0
tr=0
n.models = 5
ntrees=2000
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
tr1 = predict(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
tr1 = predict(object = GBM.model,newdata=train[1:end_trn,])#, ntrees)
pr = pr+pr1
tr = tr+tr1
}
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
#tr1 = predict(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
?predict
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
#tr1 = predict(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
#pr1 = predict(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
tr1 = predict(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
tr1 = predict(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
predict(object=GBM.model)
predict(object=GBM.model, newdata=train[(end_trn+1):end,], ntrees)
predict(object=GBM.model, newdata=train[(end_trn+1):end,])
body(add)
library(jsonlite)
serializeJSON(body(add))
typeof(body(add))
body(add)(1)
test <- read.csv(file="test.csv")
train <- read.csv(file="train.csv")
head(test)
head(train)
#y variable
survived <- train$Survived
#id
passengerId <- test$PassengerId
#remove from the training sample
train = train[,-2]
end_trn = nrow(train)
#combine the two sets
train <- rbind(train, test)
#Age replace with mean
train$Age[is.na(train$Age)] <- 30
end = nrow(train)
#remove columns
train = train[,c(-1,-3,-8,-10,-11)]
head(train)
library(gbm)
set.seed(123)
pr=0
tr=0
n.models = 5
ntrees=2000
gbm.f9t
gbm.fity
gbm.fit
??gbm.fit
?predict.gbm
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict.gbm(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
tr1 = predict.gbm(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
pr = pr/n.models
tr = tr/n.models
head(pr)
head(tr)
summary(GBM.model)
GBM.model
head(train)
predict.gbm(object = GBM.model, newdata=data.frame("Pclass"=1, "Sex"="male", "Age"=20, "SibSp"=1, "Parch"=0, "Fare"=7.2500), ntrees)
test <- read.csv(file="test.csv")
train <- read.csv(file="train.csv")
head(test)
head(train)
#y variable
survived <- train$Survived
#id
passengerId <- test$PassengerId
#remove from the training sample
train = train[,-2]
end_trn = nrow(train)
#combine the two sets
train <- rbind(train, test)
#Age replace with mean
train$Age[is.na(train$Age)] <- 30
end = nrow(train)
#remove columns
train = train[,c(-1,-3,-8,-10,-11)]
head(train)
library(gbm)
set.seed(123)
pr=0
tr=0
n.models = 5
ntrees=2000
for(i in 1:n.models){
GBM.model = gbm.fit(
x=train[1:end_trn,], y = survived,
distribution= "gaussian",
n.trees = ntrees,
shrinkage = 0.01,
interaction.depth = 25,
n.minobsinnode = 5,
verbose = TRUE)
#test set prediction
pr1 = predict.gbm(object=GBM.model,newdata=train[(end_trn+1):end,], ntrees)
#training set prediction
tr1 = predict.gbm(object = GBM.model,newdata=train[1:end_trn,], ntrees)
pr = pr+pr1
tr = tr+tr1
}
pr = pr/n.models
tr = tr/n.models
head(pr)
head(tr)
summary(GBM.model)
GBM.model
head(trani)
head(train)
predictTitanic <- function (Pclass, Sex, Age, SibSp, Parch, Fare) {
return(predict.gbm(object=GBM.model, newdata=data.frame("Pclass"=Pclass, "Sex"=Sex, "Age"=Age, "SibSp"=SibSp, "Parch"=Parch, "Fare"=Fare), 2000))
}
predictTitanic(1, "male", 20, 1, 0, 7.5)
predictTitanic(1, "female", 20, 1, 0, 7.5)
predictTitanic(1, "female", 20, 1, 0, 30.5)
library(codetools)
findGlobals(predictTitanic)
publishWebService("predictTitanic", "TitanicDemo", list("Pclass"="int", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="int"), list("score"="float"), wsID, auth)
endpoint <- getEndpointsT(wsID, auth, '1658deea20e311e5910c0d91702e7cb7')
consumeSingleRequest(endpoint[[1]]["PrimaryKey"], paste(endpoint[[1]]["ApiLocation"],"/execute?api-version=2.0&details=true",sep=""), list("Pclass", "Sex", "Age", "SibSp", "Parch", "Fare"), list(1, "male", "20", "1", "0", "8"))
library(RCurl)
consumeSingleRequest(endpoint[[1]]["PrimaryKey"], paste(endpoint[[1]]["ApiLocation"],"/execute?api-version=2.0&details=true",sep=""), list("Pclass", "Sex", "Age", "SibSp", "Parch", "Fare"), list(1, "male", "20", "1", "0", "8"))
consumeSingleRequest(endpoint[[1]]["PrimaryKey"], paste(endpoint[[1]]["ApiLocation"],"/execute?api-version=2.0&details=true",sep=""), list("Pclass", "Sex", "Age", "SibSp", "Parch", "Fare"), list(1, "male", "20", "1", "0", "8"))
endpoint
consumeSingleRequest(endpoint[[1]]["PrimaryKey"], paste(endpoint[[1]]["ApiLocation"],"/execute?api-version=2.0&details=true",sep=""), list("Pclass", "Sex", "Age", "SibSp", "Parch", "Fare"), list(1, "male", 20, 1, 0, 8))
