#' @title Package a function's dependencies into a base64 encoded string
#' @description
#' This is a helper function to extract object and package dependencies
#' then pack them into a .zip, then a base64 string
#' packDependencies()
#' @export internal
#' @param closure functionName - function to package dependencies from
#' @return encoded zip - will return false if nothing was zipped
#############################################################
packDependencies <- function(functionName) {
# Recursive step for package packaging
recurPkg <- function(pkgName, pkgList) {
# if the package isn't already in the list
if (!(pkgName %in% pkgList)) {
# add it
pkgList <- c(pkgName, pkgList)
# if the package is available on a repo
if (pkgName %in% row.names(available.packages())) {
# iterate through the dependencies and check if need to add them
for (pkg in strsplit(available.packages()[pkgName, "Depends"], split=", ")[[1]]) {
# filter out duplicates, R version dependencies, and base packages
if (!(pkg %in% pkgList) && !(grepl("R \\((.*)\\)", pkg)) && (pkg %in% row.names(available.packages()))) {
# recursively call recurPkg
pkgList <- recurPkg(pkg, pkgList)
}
}
# iterate through imports
for (pkg in strsplit(available.packages()[pkgName, "Imports"], split=", ")[[1]]) {
# filter out duplicates, R version dependencies, and base packages
if (!(pkg %in% pkgList) && !(grepl("R \\((.*)\\)", pkg)) && (pkg %in% row.names(available.packages()))) {
# recursively call recurPkg
pkgList <- recurPkg(pkg, pkgList)
}
}
}
}
# return updated list of packages
return(pkgList)
}
# Recursive step for object packaging
# NOTE: will not work if the user function specifies the names directly, e.g. won't find rjson::toJSON
# from findGlobals man page: "R semantics only allow variables that might be local to be identified"
recurDep <- function(objName, depList, pkgList) {
# findGlobals() gets all external dependencies
# Iterate over them
for (obj in codetools::findGlobals(get(objName))) {
name = get(obj)
# filter out primitives and duplicates
if (is.primitive(name) || (obj %in% names(depList))) {
next
}
# non-function object dependencies
else if (!is.function(name)) {
depList[[obj]] <- name
# Use the object's class to find package dependencies
objClass <- class(name)
# iterate through the class vector looking for packages
for (class in objClass) {
tryCatch({
# get the name of the package the class belongs to
nameEnv <- environment(get(class))
# filter out basic environment
if (!(identical(nameEnv, NULL)) && !(identical(nameEnv, .BaseNamespaceEnv))) {
packages <- recurPkg(paste(getNamespaceName(nameEnv)), pkgList)
}
# if unable to find package, continue
}, error = function(e) {
sprintf("%s not found", obj)
})
}
}
# user defined functions
else if (identical(environment(name), globalenv())) {
depList[[obj]] <- name
results <- recurDep(obj, depList, pkgList)
depList <- results$dependencies
pkgList <- results$packages
}
# functions from packages
else if (paste(getNamespaceName(environment(name))) != "base") {
packages <- recurPkg(paste(getNamespaceName(environment(name))), pkgList)
}
}
return(list("dependencies"=depList, "packages"=pkgList))
}
# call recurDep on the desired function and with empty lists
results <- recurDep(functionName, list(), list())
dependencies <- results$dependencies
packages <- results$packages
# save current path to restore later
start = getwd()
# go to package library, doing this to prevent zipping entire path to package
toPack <- packages
toZip = vector()
for (i in 1:length(.libPaths())) {
setwd(.libPaths()[i])
# try to find the package in the directory and zip it
for (pkg in toPack) {
if (file.exists(pkg)) {
# save it to original directory
zip(paste(start, paste(pkg, "zip", sep="."), sep="/"), pkg)
toZip <- c(toZip, paste(pkg, "zip", sep="."))
# remove the package from the list of packages to pack
toPack <- toPack[toPack != pkg]
}
}
# if done packing, break
if (length(toPack) == 0) {
break
}
}
# go back to where the user started
setwd(start)
# make sure that all packages were found
if (length(toPack) > 0) {
stop("Error: unable to locate one or more packages. Please make sure the packages used are in at least one of the library paths.")
}
# generate a GUID to act as a file name to store packages, R data
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# dump objects, functions, etc. into .rdta file
if (length(dependencies) > 0) {
# maybe can save directly as a .zip and skip the zip() call?
save(dependencies, file=guid)
toZip <- c(toZip, guid)
}
# zip up everything
if (length(toZip) > 0) {
zip(zipfile=guid, files=toZip)
zipEnc <- base64enc::base64encode(paste(guid, ".zip", sep=""))
# delete the packages
for (pkg in packages) {
file.remove(paste(pkg, "zip", sep="."))
}
# delete the dependency rdta file
if (length(dependencies) > 0) {
file.remove(guid)
file.remove(paste(guid,"zip",sep="."))
}
# return the encoded zip as a string
return(list(guid, zipEnc))
}
# if nothing was zipped, return empty string to indicate
# returning two things because unable to return variable amounts
else {
return(list(guid, ""))
}
}
#############################################################
#' @title HELPER FUNCTION: Convert Format
#' @description This is a helper function to convert expected schema to API-expecting format
#' @export internal
#' @param list argList - List of expected input parameters
#' @return Converted inputSchema to the proper format
#############################################################
convert <- function(argList) {
form <- list()
for (arg in names(argList)) {
type = argList[[arg]]
if (type == "float" || type == "double") {
form[[ arg ]] <- list("type"="number", "format"=type)
}
else if (type == "date-time" || type == "string" || type == "time-span") {
form[[arg]] <- list("type"="string", "format"=type)
}
else if (type == "uint16" || type == "int16" || type == "uint32" || type == "int32" || type == "uint64" || type == "int64") {
form[[arg]] <- list("type"="integer", "format"=type)
}
else if (type == "int") {
form[[arg]] <- list("type"="integer", "format"="int32")
}
else if (type == "bool" || type == "boolean") {
form[[arg]] <- list("type"="boolean")
}
else {
stop(sprintf("Error: data type \"%s\" not supported", type), call. = TRUE)
}
}
return(form)
}
#############################################################
#' @title HELPER FUNCTION: Parameter Check
#' @description This is a helper function to check that the user has passed in all of the expected parameters.
#' @export internal
#' @param list userInput - List of expected input parameters
#' @param string funcName - The function that is being published
#' @return False if the input was not as expected/True if input matched expectation
#############################################################
paramCheck <- function(userInput, funcName) {
numParamsEXPECTED <- length(formals(funcName))
numParamsPASSED <- length(userInput)
if (numParamsPASSED != numParamsEXPECTED) {
errorWarning <- paste("Error: Your input Schema does not contain the proper input. You provided ", numParamsPASSED," inputs and ", numParamsEXPECTED," were expected",sep="")
stop(errorWarning, call. = TRUE)
return(FALSE)
}
else {
return(TRUE)
}
}
#############################################################
#' @title Publish Web Service
#' @description
#' This function publishes code given a valid workspace ID and authentication token. The function expects the function name, service name, and
#' the input and output schemas from the user.
#' The user can expect a list of the web service details, the default endpoint details and the consumption function and use this information to access
#' the published function.
#' @param string functionName - The function that is being published
#' @param string serviceName - The name they would like the function published under
#' @param list inputSchema - List of expected input parameters
#' expecting inputSchema = list("arg1"="type", "arg2"="type", ...)
#' @param list outputSchema - List of expected output
#' expecting outputSchema = list("output1"="type", "output2"="type", ...)
#' @param string wkID - The workspace ID
#' @param string authToken - The primary authorization token
#' @return List of webservice details, default endpoint details, and the consumption function
#' @examples
#' # create a function to make predictions using the trained model
#' # For this example we will use the Titanic
#' I.e. predictTitanic <- function (Pclass, Sex, Age, SibSp, Parch, Fare)
#' # Sample local call
#' predictTitanic(1, "male", 20, 2, 0, 8.50)
#' #Publish the function
#' TitanicService <- publishWebService("predictTitanic", "TitanicDemo", list("Pclass"="string", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="float"), list("survProb"="float"), wsID, wsAuth)
#############################################################
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure schema inputted matches function signature
paramCheck(inputSchema, functionName)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(inputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(outputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
# TODO: consolidate json packages, i.e. use only one if possible
body = RJSONIO::toJSON(req)
#print(sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))))
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid to serve as the web service ID
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
newService <- RJSONIO::fromJSON(h$value())
# Use discovery functions to get endpoints for immediate use
# NOTE: switch from internal URL for production
endpoints <- getEndpoints(wkID, authToken, newService["Id"], internalURL)
# add suffix to the API location so it can actually be used
for (i in 1:length(endpoints)) {
endpoints[[i]]$ApiLocation <- paste(endpoints[[i]]$ApiLocation, "/execute?api-version=2.0&details=true",sep="")
}
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=newService, "endpoints"=endpoints))
}
#############################################################
#' @title Update a Published Web Service
#' @description
#' This function updates published code given a valid workspace ID and authentication token. The function expects the function name, service id, and
#' the input and output schemas from the user.
#' The user can expect a list of the web service details, the default endpoint details and the consumption function and use this information to access
#' the published function.
#' @param string functionName - The function that is being updated
#' @param string serviceGUID - The name they would like the function published under
#' ((Note: cannot change the service name))
#' @param list inputSchema - List of expected input parameters
#' expecting inputSchema = list("arg1"="type", "arg2"="type", ...)
#' @param list outputSchema - List of expected output
#' expecting outputSchema = list("output1"="type", "output2"="type", ...)
#' @param string wkID - The workspace ID
#' @param string authToken - The primary authorization token
#' @return List of webservice details, default endpoint details, and the consumption function
#' @examples
#' # create a function to make predictions using the trained model
#' I.e. predictTitanic <- function (Pclass, Sex, Age, SibSp, Parch, Fare)
#' # Sample local call
#' predictTitanic(1, "male", 20, 2, 0, 8.50)
#' # Publish the function
#' TitanicService <- publishWebService("predictTitanic", "TitanicDemo", list("Pclass"="string", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="float"), list("survProb"="float"), wsID, wsAuth)
#' # Let's say that predictTitanic was changed and we want to republish
#' TitanicService <- updateWebService("predictTitanic", "TitanicDemo", list("Pclass"="string", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="float"), list("survProb"="float"), wsID, wsAuth)
#############################################################
updateWebService <- function(functionName, wsID, inputSchema, outputSchema, wkID, authToken) {
# Make sure schema inputted matches function signature
paramCheck(inputSchema, functionName)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(inputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(outputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
# TODO: consolidate json packages, i.e. use only one if possible
body = RJSONIO::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, wsID),
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
updatedService <- RJSONIO::fromJSON(h$value())
# Use discovery functions to get default endpoint for immediate use
# NOTE: switch from internal URL for production
endpoints <- getEndpoints(wkID, authToken, newService["Id"], internalURL)
for (i in 1:length(endpoints)) {
endpoints[[i]]$ApiLocation <- paste(endpoints[[i]]$ApiLocation, "/execute?api-version=2.0&details=true",sep="")
}
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=updatedService, "endpoints"=endpoints))
}
#############################################################
# API URLs
#############################################################
wsURL = "https://management-tm.azureml.net/workspaces/%s/webservices"
wsURLdet = "https://management-tm.azureml.net/workspaces/%s/webservices/%s"
epURL = "https://management-tm.azureml.net/workspaces/%s/webservices/%s/endpoints"
epURLdet = "https://management-tm.azureml.net/workspaces/%s/webservices/%s/endpoints/%s"
# remove in real version
testURL = "https://hiteshsm.cloudapp.net/workspaces/%s/webservices/%s/endpoints"
internalURL = "https://management.azureml-int.net/workspaces/%s/webservices/%s/endpoints"
#############################################################
#' @title Get FrameWork
#' @description
#' Framework for making an HTTP request to the URL specified
#' returns a list of lists, so that the elements can be accessed
#' via double bracket notation
#' @param tUrl The URL from the published web service
#' @param authToken The authentication token for the AzureML account being used
#' @return prints the framework
#' @examples
#' results[[1]]
#############################################################
getFramework <- function(tUrl, authToken) {
# Collectors for API response
h = RCurl::basicTextGatherer()
hdr = RCurl::basicTextGatherer()
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Craft request header and execute
auth = paste('Bearer', authToken, sep=' ')
h$reset()
RCurl::curlPerform(url = tUrl,
httpheader=c('Authorization' = auth, 'Content-Type' = "application/json", 'Accept' = "application/json"),
writefunction = h$update,
headerfunction = hdr$update,
verbose = TRUE,
ssl.verifyHost = FALSE,
ssl.verifyPeer = FALSE)
# Print results
return(RJSONIO::fromJSON(h$value()))
}
#############################################################
#' @title Get Web Services
#' @description Get a list of webservices available to a workspace
#'
#' @param wkID The workspace ID
#' @param authToken The primary authorization token
#' @return Returns a list of lists, where each web service is represented
#' as a nested named list with the following fields:
#' "Id", "Name", "Description", "CreationTime", "WorkspaceId", "DefaultEndpointName"
#' @examples
#' DELETE TOKENS IN REAL VERSION
#' services = getWebServices("c01fb89129aa4ef0a19affa7f95ecbbc", "523709d06661441bbf129d68f84cd6a4")
#' serviceID = services[[1]]["Id"]
#############################################################
getWebServices <- function(wkID, authToken, url=wsURL) {
return(getFramework(sprintf(url, wkID), authToken))
}
#############################################################
#' @title Get Workspace Details
#' @description Get detailed information about a specific webservice
#'
#' @param wkID The workspace ID
#' @param authToken The primary authorization token
#' @param wsID The webservice ID
#' @return Returns a named list representing the web service
#' with the following fields:
#' "Id", "Name", "Description", "CreationTime", "WorkspaceId", "DefaultEndpointName"
#' @examples
#' << Please note that you will need to retrieve all of the signature details from your AzureML account >>
#' services = getWebServices("abcdefghijklmnopqrstuvwxyz123456", "abcdefghijklmnopqrstuvwxyz123456")
#############################################################
getWSDetails <- function(wkID, authToken, wsID, url=wsURLdet) {
return(getFramework(sprintf(url, wkID, wsID), authToken))
}
#############################################################
#' @title Get Endpoints
#' @description Get the endpoints that are part of a web service
#'
#' @param wkID The workspace ID
#' @param authToken The primary authorization token
#' @param wsID The webservice ID
#' @return Returns a list of lists, where each endpoint is represented
#' as a nested named list with the following fields:
#' "Name", "Description", "CreationTime", "WorkspaceId", "WebServiceId",
#' "HelpLocation", "PrimaryKey", "SecondaryKey", "ApiLocation", "Version",
#' "MaxConcurrentCalls", "DiagnosticsTraceLevel", "ThrottleLevel"
#' @examples
#' << Please note that you will need to retrieve all of the signature details from your AzureML account >>
#' endpoints = getEndpoints("abcdefghijklmnopqrstuvwxyz123456", "abcdefghijklmnopqrstuvwxyz123456", "abcdefghijklmnopqrstuvwxyz123456")
#############################################################
getEndpoints <- function(wkID, authToken, wsID, url=epURL) {
endpoints <- getFramework(sprintf(url, wkID, wsID), authToken)
for (i in 1:length(endpoints)) {
endpoints[[i]]$ApiLocation <- paste(endpoints[[i]]$ApiLocation, "/execute?api-version=2.0&details=true",sep="")
}
return(endpoints)
}
#############################################################
#' @title get EndPoint Details
#' @description Get the details on a specific endpoint
#'
#' @param wkID The workspace ID
#' @param authToken The primary authorization token
#' @param wsID The webservice ID
#' @param epID The endpoint name
#' @return Returns a named list representing the endpoint with the following fields:
#' "Name", "Description", "CreationTime", "WorkspaceId", "WebServiceId",
#' "HelpLocation", "PrimaryKey", "SecondaryKey", "ApiLocation", "Version",
#' "MaxConcurrentCalls", "DiagnosticsTraceLevel", "ThrottleLevel"
#' @examples
#' << Please note that you will need to retrieve all of the signature details from your AzureML account >>
#' defaultEP = getEPDetails("abcdefghijklmnopqrstuvwxyz123456", "abcdefghijklmnopqrstuvwxyz123456", "abcdefghijklmnopqrstuvwxyz123456", "default")
#############################################################
getEPDetails <- function(wkID, authToken, wsID, epID, url=epURLdet) {
endpoint <- getFramework(sprintf(url, wkID, wsID, epID), authToken)
endpoint$ApiLocation <- paste(endpoint$ApiLocation, "/execute?api-version=2.0&details=true",sep="")
}
endpoints <- getEndpoints(wsID, wsAuth, MSFTonline[[1]]$Id, url=internalURL)
endpoints
getEPDetails(wsID, wsAuth, MSFTonline[[1]]Id, "default", url=internalURL)
getEPDetails(wsID, wsAuth, MSFTonline[[1]]$Id, "default", url=internalURL)
getEPDetails <- function(wkID, authToken, wsID, epID, url=epURLdet) {
endpoint <- getFramework(sprintf(url, wkID, wsID, epID), authToken)
endpoint$ApiLocation <- paste(endpoint$ApiLocation, "/execute?api-version=2.0&details=true",sep="")
return(endpoint)
}
getEPDetails(wsID, wsAuth, MSFTonline[[1]]$Id, "default", url=internalURL)
getEPDetails <- function(wkID, authToken, wsID, epID, url=epURLdet) {
endpoint <- getFramework(sprintf(url, wkID, wsID, epID), authToken)
endpoint[[1]]$ApiLocation <- paste(endpoint[[1]]$ApiLocation, "/execute?api-version=2.0&details=true",sep="")
return(endpoint)
}
getEPDetails(wsID, wsAuth, MSFTonline[[1]]$Id, "default", url=internalURL)
add <- function (x, y) {
return(x + y)
}
getFunctionString(add)
add <- function (x, y) {
print("This will add x and y")
return(x + y)
}
getFunctionString(add)
