getwd()
install.packages("maml_0.1.tar.gz", repos=NULL, type="source")
?fromJSON
library(RJSONIO)
?fromJSON
install.packages("maml_0.1.tar.gz", repos=NULL, type="source")
install.packages("maml_0.1.tar.gz", repos=NULL, type="source")
?predictService
library(maml)
?predictService
install.packages("maml_0.1.tar.gz", repos=NULL, type="source")
library(maml)
?predictService
install.packages("maml_0.1.tar.gz", repo=NULL, type="source")
library(maml)
?getEndpoints
getwd()
install.packages("maml_0.1.tar.gz", repos=NULL, dependencies = TRUE)
install.packages("maml_0.1.tar.gz", repos=NULL, type="source, dependencies = TRUE)
""
)
""
install.packages("maml_0.1.tar.gz", repos=NULL, type="source", dependencies = TRUE)
install(maml)
library(maml)
getWebServices("c01fb89129aa4ef0a19affa7f95ecbbc", "523709d06661441bbf129d68f84cd6a4")
services <- getWebServices("c01fb89129aa4ef0a19affa7f95ecbbc", "523709d06661441bbf129d68f84cd6a4")
services
endpoints <- getEndpoints("c01fb89129aa4ef0a19affa7f95ecbbc", "523709d06661441bbf129d68f84cd6a4", services[[2]]["Id"])
file <- "rjson"
library(file, character.only=TRUE)
toJSON
packDependencies <- function(funName) {
# lists for storing objects and packages
dependencies = list()
packages = list()
# generate a GUID to act as a file name to store packages, R data
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# NOTE: will not work if the user function specifies the names directly, e.g. won't find rjson::toJSON
# from findGlobals man page: "R semantics only allow variables that might be local to be identified"
# CONSIDER: how robust is this filtering? need to verify
for (obj in codetools::findGlobals(get(funName))) {
name = get(obj)
# filter out primitives and duplicates
if (is.primitive(name) || (obj %in% names(dependencies))) {
next
}
# get in-memory objects
# Can nonfunction objects have dependencies???
else if (!is.function(name)) {
dependencies[[obj]] <- name
}
# grab user defined functions
else if (identical(environment(name), globalenv())) {
dependencies[[obj]] <- name
# recursively get dependencies
results <- recurDep(obj, dependencies, packages)
dependencies <- results$dependencies
packages <- results$packages
}
# get the names of packages of package functions
# filter out base functions
else if (paste(getNamespaceName(environment(name))) != "base") {
# recursively get packages
packages <- recurPkg(paste(getNamespaceName(environment(name))), packages)
}
# need an else branch?
}
# save current path to restore to later
start = getwd()
# go to package library, doing this to prevent tarballing entire path to package
toPack <- packages
toZip = vector()
for (i in 1:length(.libPaths())) {
setwd(.libPaths()[i])
# try to find and zip up the packages
for (pkg in toPack) {
if (file.exists(pkg)) {
zip(paste(start, paste(pkg, "zip", sep="."), sep="/"), pkg)
toZip <- c(toZip, paste(pkg, "zip", sep="."))
toPack <- toPack[toPack != pkg]
print(length(toPack))
}
}
# if done packing, break
if (length(toPack) == 0) {
break
}
if (i == length(.libPaths())) {
# error: can't find packages
stop("Error: unable to locate packages. Please make sure the packages used are in at least one of the library paths.")
}
}
# go back to where the user started
setwd(start)
# objects, functions, etc.
if (length(dependencies) > 0) {
# maybe can save directly as a .zip and skip the zip() call?
save(dependencies, file=guid)
toZip <- c(toZip, guid)
}
# zip up everything
if (length(toZip) > 0) {
zip(zipfile=guid, files=toZip)
zipEnc <- base64enc::base64encode(paste(guid, ".zip", sep=""))
# delete the packages
for (pkg in packages) {
# did I miss anything? maybe extra files floating around
file.remove(paste(pkg, "zip", sep="."))
}
# delete the dependency rdta file
file.remove(guid)
file.remove(paste(guid,"zip",sep="."))
# return the encoded zip as a string
return(list(guid, zipEnc))
}
# if nothing was zipped, return false
else {
return(list(guid, ""))
}
}
##################################################################################
# recurDep()
# Helper function to recursively gather dependencies from user defined-functions
# Similar structure to packDependencies()
##################################################################################
recurDep <- function(funName, dependencies, packages) {
for (obj in codetools::findGlobals(get(funName))) {
name = get(obj)
if (is.primitive(name) || (obj %in% names(dependencies))) {
next
}
else if (!is.function(name)) {
dependencies[[obj]] <- name
}
else if (identical(environment(name), globalenv())) {
dependencies[[obj]] <- name
results <- recurDep(obj, dependencies, packages)
dependencies <- results$dependencies
packages <- results$packages
}
else if (paste(getNamespaceName(environment(name))) != "base") {
packages <- recurPkg(paste(getNamespaceName(environment(name))), packages)
}
}
return(list("dependencies"=dependencies, "packages"=packages))
}
##################################################################################
# recurPkg()
# Helper function to recursively gather dependencies from user defined-functions
##################################################################################
recurPkg <- function(pkgName, packages) {
# if the package isn't already in the list
if (!(pkgName %in% packages)) {
# add it
packages <- c(pkgName, packages)
pkgDeps <- available.packages()
# iterate through the dependencies and check if need to add them
for (pkg in strsplit(available.packages()[pkgName, "Depends"], split=", ")[[1]]) {
# filtout duplicates and R version dependencies
if (!(pkg %in% packages) && !(grepl("R \\((.*)\\)", pkg)) && (pkg %in% row.names(available.packages()))) {
# recursively call recurPkg
packages <- recurPkg(pkg, packages)
}
}
}
# return updated list of packages
return(packages)
}
getwd()
setwd("Azure-MachineLearning-ClientLibrary-R/maml/R")
setwd("..")
add <- function(x) {
print(findGlobals(add))
return(add2(x))
}
add2 <- function(x) {
print(toJSON(list("test")))
return(x+a[[1]])
}
packDependencies("add2")
a <- list(5)
packDependencies("add2")
library(jsonlite)
library(codetools)
packDependencies("add2")
packDependencies <- function(funName) {
# lists for storing objects and packages
dependencies = list()
packages = list()
# generate a GUID to act as a file name to store packages, R data
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# NOTE: will not work if the user function specifies the names directly, e.g. won't find rjson::toJSON
# from findGlobals man page: "R semantics only allow variables that might be local to be identified"
# CONSIDER: how robust is this filtering? need to verify
for (obj in codetools::findGlobals(get(funName))) {
name = get(obj)
# filter out primitives and duplicates
if (is.primitive(name) || (obj %in% names(dependencies))) {
next
}
# get in-memory objects
# Can nonfunction objects have dependencies???
else if (!is.function(name)) {
dependencies[[obj]] <- name
}
# grab user defined functions
else if (identical(environment(name), globalenv())) {
dependencies[[obj]] <- name
# recursively get dependencies
results <- recurDep(obj, dependencies, packages)
dependencies <- results$dependencies
packages <- results$packages
}
# get the names of packages of package functions
# filter out base functions
else if (paste(getNamespaceName(environment(name))) != "base") {
# recursively get packages
packages <- recurPkg(paste(getNamespaceName(environment(name))), packages)
}
# need an else branch?
}
# save current path to restore to later
start = getwd()
# go to package library, doing this to prevent tarballing entire path to package
toPack <- packages
toZip = vector()
for (i in 1:length(.libPaths())) {
setwd(.libPaths()[i])
# try to find and zip up the packages
for (pkg in toPack) {
if (file.exists(pkg)) {
zip(paste(start, paste(pkg, "zip", sep="."), sep="/"), pkg)
toZip <- c(toZip, paste(pkg, "zip", sep="."))
toPack <- toPack[toPack != pkg]
}
}
# if done packing, break
if (length(toPack) == 0) {
break
}
if (i == length(.libPaths())) {
# error: can't find packages
stop("Error: unable to locate packages. Please make sure the packages used are in at least one of the library paths.")
}
}
# go back to where the user started
setwd(start)
# objects, functions, etc.
if (length(dependencies) > 0) {
# maybe can save directly as a .zip and skip the zip() call?
save(dependencies, file=guid)
toZip <- c(toZip, guid)
}
# zip up everything
if (length(toZip) > 0) {
zip(zipfile=guid, files=toZip)
zipEnc <- base64enc::base64encode(paste(guid, ".zip", sep=""))
# delete the packages
for (pkg in packages) {
# did I miss anything? maybe extra files floating around
file.remove(paste(pkg, "zip", sep="."))
}
# delete the dependency rdta file
file.remove(guid)
file.remove(paste(guid,"zip",sep="."))
# return the encoded zip as a string
return(list(guid, zipEnc))
}
# if nothing was zipped, return false
else {
return(list(guid, ""))
}
}
