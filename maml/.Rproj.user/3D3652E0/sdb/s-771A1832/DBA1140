{
    "contents" : "#############################################################\n# String constants\n#############################################################\npublishURL <- \"https://management.azureml-int.net/workspaces/%s/webservices/%s\" ## REMOVE SSL IGNORING FOR REAL VERSION ##\n#publishURL <- \"https://hiteshsm.cloudapp.net/workspaces/%s/webservices/%s\" ## REMOVE SSL IGNORING FOR REAL VERSION ##\nwrapper <- \"inputDF <- maml.mapInputPort(1)\\r\\noutputDF <- matrix(ncol = %s, nrow = nrow(inputDF))\\r\\ncolnames(outputDF) <- list(%s)\\r\\noutputDF <- data.frame(outputDF)\\r\\nfor (file in list.files(\\\"src\\\")) {\\r\\n  if (file == \\\"%s\\\") {\\r\\n    load(\\\"src/%s\\\")\\r\\n    for (item in names(dependencies)) {\\r\\n      assign(item, dependencies[[item]])\\r\\n    }\\r\\n  }\\r\\n  else {\\r\\n    if (!(file %%in%% installed.packages()[,\\\"Package\\\"])) {\\r\\n      install.packages(paste(\\\"src\\\", file, sep=\\\"/\\\"), lib=\\\".\\\", repos=NULL, verbose=TRUE)\\r\\n    }\\r\\n    library(strsplit(file, \\\"\\\\\\\\.\\\")[[1]][[1]], character.only=TRUE)\\r\\n  }\\r\\n}\\r\\naction <- %s\\r\\nfor (i in 1:nrow(inputDF)) {\\r\\n  outputDF[i,] <- do.call(\\\"action\\\", as.list(inputDF[i,]))\\r\\n}\\r\\nmaml.mapOutputPort(\\\"outputDF\\\")\"\n\n\n\n#############################################################\n#' @title Get Function Source Code as a String\n#' @description\n#' This is a helper function that will convert a function's source code to a string\n#' Also consider paste(body(fun())) or getAnywhere()\n#' @param x Name of the function to convert to a string\n#' @return function in string format\n#############################################################\ngetFunctionString <- function (x)\n{\n  if (tryCatch(!is.character(x), error = function(e) TRUE))\n    x <- as.character(substitute(x))\n  objs <- list()\n  where <- character()\n  visible <- logical()\n  if (length(pos <- find(x, numeric = TRUE))) {\n    objs <- lapply(pos, function(pos, x) get(x, pos = pos),\n                   x = x)\n    where <- names(pos)\n    visible <- rep.int(TRUE, length(pos))\n  }\n  if (length(grep(\".\", x, fixed = TRUE))) {\n    np <- length(parts <- strsplit(x, \".\", fixed = TRUE)[[1L]])\n    for (i in 2:np) {\n      gen <- paste(parts[1L:(i - 1)], collapse = \".\")\n      cl <- paste(parts[i:np], collapse = \".\")\n      if (gen == \"\" || cl == \"\")\n        next\n      Call <- substitute(getS3method(gen, cl, TRUE), list(gen = gen,\n                                                          cl = cl))\n      f <- eval.parent(Call)\n      if (!is.null(f) && !is.null(environment(f))) {\n        ev <- topenv(environment(f), baseenv())\n        nmev <- if (isNamespace(ev))\n          getNamespaceName(ev)\n        else NULL\n        objs <- c(objs, f)\n        msg <- paste(\"registered S3 method for\", gen)\n        if (!is.null(nmev))\n          msg <- paste(msg, \"from namespace\", nmev)\n        where <- c(where, msg)\n        visible <- c(visible, FALSE)\n      }\n    }\n  }\n  for (i in loadedNamespaces()) {\n    ns <- asNamespace(i)\n    if (exists(x, envir = ns, inherits = FALSE)) {\n      f <- get(x, envir = ns, inherits = FALSE)\n      objs <- c(objs, f)\n      where <- c(where, paste(\"namespace\", i, sep = \":\"))\n      visible <- c(visible, FALSE)\n    }\n  }\n  ln <- length(objs)\n  dups <- rep.int(FALSE, ln)\n  if (ln > 1L)\n    for (i in 2L:ln) for (j in 1L:(i - 1L)) if (identical(objs[[i]],\n                                                          objs[[j]], ignore.environment = TRUE)) {\n      dups[i] <- TRUE\n      break\n    }\n  res <- list(name = x, objs = objs, where = where, visible = visible,\n              dups = dups)\n  class(res) <- \"getAnywhere\"\n\n  #don't show the full response!\n  #res\n  # Might return multiple objects in a list, currently returning first object (BIG ASSUMPTION)\n  #return(objs[1])\n  return(gsub(\"\\n\", \"\\r\\n\", gsub(\"\\\"\", \"\\\\\\\"\", objs[1])))\n}\n\n\n\n#############################################################\n# TODO: add error handling at each step\n# TODO: suppress the red text?\n#############################################################\n#' @title HELPER FUNCTION: Package Dependencies\n#' @description\n#' This is a helper function to extract object and package dependencies\n#' then pack them into a .zip, then a base64 string\n#' packDependencies()\n#' @param closure functionName - function to package dependencies from\n#' @return encoded zip - will return false if nothing was zipped\n#############################################################\npackDependencies <- function(functionName) {\n  # lists for storing objects and packages\n  dependencies = list()\n  packages = list()\n\n  # generate a GUID to act as a file name to store packages, R data\n  guid = gsub(\"-\", \"\", uuid::UUIDgenerate(use.time=TRUE))\n\n  # NOTE: will not work if the user function specifies the names directly, e.g. won't find rjson::toJSON\n  # from findGlobals man page: \"R semantics only allow variables that might be local to be identified\"\n  # CONSIDER: how robust is this filtering? need to verify\n  for (obj in codetools::findGlobals(get(functionName))) {\n    name = get(obj)\n\n    # filter out primitives and duplicates\n    if (is.primitive(name) || (obj %in% names(dependencies))) {\n      next\n    }\n\n    # get in-memory objects\n    # Can nonfunction objects have dependencies???\n    else if (!is.function(name)) {\n      dependencies[[obj]] <- name\n      nameEnv <- environment(get(class(name)))\n      if (!(identical(nameEnv, NULL)) && !(identical(nameEnv, .BaseNamespaceEnv))) {\n        packages <- recurPkg(paste(getNamespaceName(nameEnv)), packages)\n      }\n    }\n\n    # grab user defined functions\n    else if (identical(environment(name), globalenv())) {\n      dependencies[[obj]] <- name\n      # recursively get dependencies\n      results <- recurDep(obj, dependencies, packages)\n      dependencies <- results$dependencies\n      packages <- results$packages\n    }\n\n    # get the names of packages of package functions\n    # filter out base functions\n    else if (paste(getNamespaceName(environment(name))) != \"base\") {\n      # recursively get packages\n      packages <- recurPkg(paste(getNamespaceName(environment(name))), packages)\n    }\n\n    # need an else branch?\n  }\n\n  # save current path to restore to later\n  start = getwd()\n  # go to package library, doing this to prevent zipping entire package\n  toPack <- packages\n  toZip = vector()\n  for (i in 1:length(.libPaths())) {\n    setwd(.libPaths()[i])\n    # try to find and zip up the packages\n    for (pkg in toPack) {\n      if (file.exists(pkg)) {\n        zip(paste(start, paste(pkg, \"zip\", sep=\".\"), sep=\"/\"), pkg)\n        toZip <- c(toZip, paste(pkg, \"zip\", sep=\".\"))\n        toPack <- toPack[toPack != pkg]\n      }\n    }\n\n    # if done packing, break\n    if (length(toPack) == 0) {\n      break\n    }\n    if (i == length(.libPaths())) {\n      # error: can't find packages\n      stop(\"Error: unable to locate packages. Please make sure the packages used are in at least one of the library paths.\")\n    }\n  }\n  # go back to where the user started\n  setwd(start)\n\n  # objects, functions, etc.\n  if (length(dependencies) > 0) {\n    # maybe can save directly as a .zip and skip the zip() call?\n    save(dependencies, file=guid)\n    toZip <- c(toZip, guid)\n  }\n\n  # zip up everything\n  if (length(toZip) > 0) {\n    zip(zipfile=guid, files=toZip)\n    zipEnc <- base64enc::base64encode(paste(guid, \".zip\", sep=\"\"))\n\n    # delete the packages\n    for (pkg in packages) {\n      # did I miss anything? maybe extra files floating around\n      file.remove(paste(pkg, \"zip\", sep=\".\"))\n    }\n    # delete the dependency rdta file\n    file.remove(guid)\n    file.remove(paste(guid,\"zip\",sep=\".\"))\n\n    # return the encoded zip as a string\n    return(list(guid, zipEnc))\n  }\n  # if nothing was zipped, return false\n  else {\n    return(list(guid, \"\"))\n  }\n}\n\n\n\n#############################################################\n#' @title HELPER FUNCTION: Recursive Dependencies\n#' @description This is helper function to recursively gather dependencies from user defined-functions\n#' Similar structure to packDependencies()\n#' recurDep()\n#' @param string functionName - Name of function to recursively gather dependencies from\n#' @param list dependencies - List of package dependencies\n#' @param list packages - Name of available packages\n#' @return list of packages and dependencies\n#############################################################\nrecurDep <- function(functionName, dependencies, packages) {\n  for (obj in codetools::findGlobals(get(functionName))) {\n    name = get(obj)\n    if (is.primitive(name) || (obj %in% names(dependencies))) {\n      next\n    }\n    else if (!is.function(name)) {\n      dependencies[[obj]] <- name\n    }\n    else if (identical(environment(name), globalenv())) {\n      dependencies[[obj]] <- name\n      results <- recurDep(obj, dependencies, packages)\n      dependencies <- results$dependencies\n      packages <- results$packages\n    }\n    else if (paste(getNamespaceName(environment(name))) != \"base\") {\n      packages <- recurPkg(paste(getNamespaceName(environment(name))), packages)\n    }\n  }\n  return(list(\"dependencies\"=dependencies, \"packages\"=packages))\n}\n\n\n\n#############################################################\n#' @title HELPER FUNCTION: Recursive Packaging\n#' @description This is helper function to recursively gather dependencies from user defined-functions\n#' recurPkg()\n#' @param string pkgName - Name of package to check for existence in list of packages\n#' @param list packages - Name of available packages\n#' @return list of packages\n#############################################################\nrecurPkg <- function(pkgName, packages) {\n  # if the package isn't already in the list\n  if (!(pkgName %in% packages)) {\n    # add it\n    packages <- c(pkgName, packages)\n    pkgDeps <- available.packages()\n\n    # if the package is available on a repo\n    if (pkgName %in% row.names(available.packages())) {\n      # iterate through the dependencies and check if need to add them\n      for (pkg in strsplit(available.packages()[pkgName, \"Depends\"], split=\", \")[[1]]) {\n        # filter out duplicates and R version dependencies\n        if (!(pkg %in% packages) && !(grepl(\"R \\\\((.*)\\\\)\", pkg)) && (pkg %in% row.names(available.packages()))) {\n          # recursively call recurPkg\n          packages <- recurPkg(pkg, packages)\n        }\n      }\n      # iterate through imports\n      for (pkg in strsplit(available.packages()[pkgName, \"Imports\"], split=\", \")[[1]]) {\n        # filter out duplicates and R version dependencies\n        if (!(pkg %in% packages) && !(grepl(\"R \\\\((.*)\\\\)\", pkg)) && (pkg %in% row.names(available.packages()))) {\n          # recursively call recurPkg\n          packages <- recurPkg(pkg, packages)\n        }\n      }\n    }\n  }\n  # return updated list of packages\n  return(packages)\n}\n\n\n\n\n#############################################################\n#' @title HELPER FUNCTION: Convert Format\n#' @description This is a helper function to convert expected schema to API-expecting format\n#' @param list argList - List of expected input parameters\n#' @return Converted inputSchema to the proper format\n#############################################################\nconvert <- function(argList) {\n  form <- list()\n  for (arg in names(argList)) {\n    type = argList[[arg]]\n\n    if (type == \"float\" || type == \"double\") {\n      form[[ arg ]] <- list(\"type\"=\"number\", \"format\"=type)\n    }\n    else if (type == \"date-time\" || type == \"string\" || type == \"time-span\") {\n      form[[arg]] <- list(\"type\"=\"string\", \"format\"=type)\n    }\n    else if (type == \"uint16\" || type == \"int16\" || type == \"uint32\" || type == \"int32\" || type == \"uint64\" || type == \"int64\") {\n      form[[arg]] <- list(\"type\"=\"integer\", \"format\"=type)\n    }\n    else if (type == \"int\") {\n      form[[arg]] <- list(\"type\"=\"integer\", \"format\"=\"int32\")\n    }\n    else if (type == \"bool\" || type == \"boolean\") {\n      form[[arg]] <- list(\"type\"=\"boolean\")\n    }\n    else {\n      stop(sprintf(\"Error: data type \\\"%s\\\" not supported\", type), call. = TRUE)\n    }\n  }\n  return(form)\n}\n\n\n\n\n#############################################################\n#' @title HELPER FUNCTION: Parameter Check\n#' @description This is a helper function to check that the user has passed in all of the expected parameters.\n#' @param list userInput - List of expected input parameters\n#' @param string funcName - The function that is being published\n#' @return False if the input was not as expected/True if input matched expectation\n#############################################################\nparamCheck <- function(userInput, funcName) {\n  numParamsEXPECTED <- length(formals(funcName))\n  numParamsPASSED <- length(userInput)\n\n  if (numParamsPASSED != numParamsEXPECTED) {\n    errorWarning <- paste(\"Error: Your input Schema does not contain the proper input. You provided \", numParamsPASSED,\" inputs and \", numParamsEXPECTED,\" were expected\",sep=\"\")\n    stop(errorWarning, call. = TRUE)\n    return(FALSE)\n  }\n  else {\n    return(TRUE)\n  }\n}\n\n\n\n#############################################################\n#' @title Publish Web Service\n#' @description\n#' This function publishes code given a valid workspace ID and authentication token. The function expects the function name, service name, and\n#' the input and output schemas from the user.\n#' The user can expect a list of the web service details, the default endpoint details and the consumption function and use this information to access\n#' the published function.\n#' @param string functionName - The function that is being published\n#' @param string serviceName - The name they would like the function published under\n#' @param list inputSchema - List of expected input parameters\n#' expecting inputSchema = list(\"arg1\"=\"type\", \"arg2\"=\"type\", ...)\n#' @param list outputSchema - List of expected output\n#' expecting outputSchema = list(\"output1\"=\"type\", \"output2\"=\"type\", ...)\n#' @param string wkID - The workspace ID\n#' @param string authToken - The primary authorization token\n#' @return List of webservice details, default endpoint details, and the consumption function\n#' @examples\n#' # create a function to make predictions using the trained model\n#' # For this example we will use the Titanic\n#' I.e. predictTitanic <- function (Pclass, Sex, Age, SibSp, Parch, Fare)\n#' # Sample local call\n#' predictTitanic(1, \"male\", 20, 2, 0, 8.50)\n#' #Publish the function\n#' TitanicService <- publishWebService(\"predictTitanic\", \"TitanicDemo\", list(\"Pclass\"=\"string\", \"Sex\"=\"string\", \"Age\"=\"int\", \"SibSp\"=\"int\", \"Parch\"=\"int\", \"Fare\"=\"float\"), list(\"survProb\"=\"float\"), wsID, wsAuth)\n#############################################################\npublishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {\n\n  # Make sure input schema matches function signature\n  paramCheck(inputSchema, functionName)\n\n  # Accept SSL certificates issued by public Certificate Authorities\n  options(RCurlOptions = list(cainfo = system.file(\"CurlSSL\", \"cacert.pem\", package = \"RCurl\")))\n\n  # Get and encode the dependencies\n  zipString = packDependencies(functionName)\n\n  # Build the body of the request, differing on whether or not there is a zip to upload\n  if (zipString[[2]] == \"\") {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = convert(inputSchema),\n        \"OutputSchema\" = convert(inputSchema),\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))\n      )\n    )\n  }\n  else {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = convert(inputSchema),\n        \"OutputSchema\" = convert(outputSchema),\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),\n        \"ZipContents\" = zipString[[2]]\n      )\n    )\n  }\n\n  # convert the payload to JSON as expected by API\n  # TODO: consolidate json packages, i.e. use only one if possible\n  body = RJSONIO::toJSON(req)\n  #print(sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))))\n\n  # Response gatherer\n  h = RCurl::basicTextGatherer()\n  h$reset()\n\n  # Generate unique guid\n  guid = gsub(\"-\", \"\", uuid::UUIDgenerate(use.time=TRUE))\n\n  # API call\n  RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above\n                 httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),\n                              'Content-Type' = 'application/json',\n                              'Accept' = 'application/json'),\n                 content = body,\n                 writefunction = h$update)\n\n  # TODO: format output\n  newService <- RJSONIO::fromJSON(h$value())\n\n  # Use discovery functions to get default endpoint for immediate use\n  # switch to getEndpoints() later\n  defaultEP <- getEndpoints(wkID, authToken, newService[\"Id\"], internalURL)\n\n  # Curry relevant parameters to consumption function\n  #consumption <- functional::Curry(consumeLists, \"api_key\"=defaultEP[[1]][\"PrimaryKey\"], \"requestURL\"=paste(defaultEP[[1]][\"ApiLocation\"],\"/execute?api-version=2.0&details=true\",sep=\"\"), \"columnNames\"=as.list(names(inputSchema)))\n\n  # currently returning list of webservice details, default endpoint details, consumption function, in that order\n  return(list(newService, defaultEP))#, consumption))\n}\n\n\n\n#############################################################\n#' @title Update a Published Web Service\n#' @description\n#' This function updates published code given a valid workspace ID and authentication token. The function expects the function name, service id, and\n#' the input and output schemas from the user.\n#' The user can expect a list of the web service details, the default endpoint details and the consumption function and use this information to access\n#' the published function.\n#' @param string functionName - The function that is being updated\n#' @param string serviceGUID - The name they would like the function published under\n#' ((Note: cannot change the service name))\n#' @param list inputSchema - List of expected input parameters\n#' expecting inputSchema = list(\"arg1\"=\"type\", \"arg2\"=\"type\", ...)\n#' @param list outputSchema - List of expected output\n#' expecting outputSchema = list(\"output1\"=\"type\", \"output2\"=\"type\", ...)\n#' @param string wkID - The workspace ID\n#' @param string authToken - The primary authorization token\n#' @return List of webservice details, default endpoint details, and the consumption function\n#' @examples\n#' # create a function to make predictions using the trained model\n#' I.e. predictTitanic <- function (Pclass, Sex, Age, SibSp, Parch, Fare)\n#' # Sample local call\n#' predictTitanic(1, \"male\", 20, 2, 0, 8.50)\n#' # Publish the function\n#' TitanicService <- publishWebService(\"predictTitanic\", \"TitanicDemo\", list(\"Pclass\"=\"string\", \"Sex\"=\"string\", \"Age\"=\"int\", \"SibSp\"=\"int\", \"Parch\"=\"int\", \"Fare\"=\"float\"), list(\"survProb\"=\"float\"), wsID, wsAuth)\n#' # Let's say that predictTitanic was updated to add more functionality now and we want to republish\n#' TitanicService <- updateWebService(\"predictTitanic\", \"TitanicDemo\", list(\"Pclass\"=\"string\", \"Sex\"=\"string\", \"Age\"=\"int\", \"SibSp\"=\"int\", \"Parch\"=\"int\", \"Fare\"=\"float\"), list(\"survProb\"=\"float\"), wsID, wsAuth)\n#############################################################\nupdateWebService <- function(functionName, serviceGUID, inputSchema, outputSchema, wkID, authToken) {\n\n  # Make sure input schema matches function signature\n  paramCheck(inputSchema, functionName)\n\n  # Accept SSL certificates issued by public Certificate Authorities\n  options(RCurlOptions = list(cainfo = system.file(\"CurlSSL\", \"cacert.pem\", package = \"RCurl\")))\n\n  # Get and encode the dependencies\n  zipString = packDependencies(functionName)\n\n  # Build the body of the request, differing on whether or not there is a zip to upload\n  if (zipString[[2]] == \"\") {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = convert(inputSchema),\n        \"OutputSchema\" = convert(inputSchema),\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))\n      )\n    )\n  }\n  else {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = convert(inputSchema),\n        \"OutputSchema\" = convert(outputSchema),\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),\n        \"ZipContents\" = zipString[[2]]\n      )\n    )\n  }\n\n  # convert the payload to JSON as expected by API\n  # TODO: consolidate json packages, i.e. use only one if possible\n  body = RJSONIO::toJSON(req)\n  #print(sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))))\n\n  # Response gatherer\n  h = RCurl::basicTextGatherer()\n  h$reset()\n\n  # Generate unique guid\n  #guid = gsub(\"-\", \"\", uuid::UUIDgenerate(use.time=TRUE))\n  guid = serviceGUID\n\n  # API call\n  RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above\n                 httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),\n                              'Content-Type' = 'application/json',\n                              'Accept' = 'application/json'),\n                 content = body,\n                 writefunction = h$update)\n\n  # TODO: format output\n  newService <- RJSONIO::fromJSON(h$value())\n\n  # Use discovery functions to get default endpoint for immediate use\n  # switch to getEndpoints() later\n  defaultEP <- getEndpoints(wkID, authToken, newService[\"Id\"], internalURL)\n\n  # Curry relevant parameters to consumption function\n  #consumption <- functional::Curry(consumeLists, \"api_key\"=defaultEP[[1]][\"PrimaryKey\"], \"requestURL\"=paste(defaultEP[[1]][\"ApiLocation\"],\"/execute?api-version=2.0&details=true\",sep=\"\"), \"columnNames\"=as.list(names(inputSchema)))\n\n  # currently returning list of webservice details, default endpoint details, consumption function, in that order\n  return(list(newService, defaultEP))#, consumption))\n}\n",
    "created" : 1437517539142.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1551989063",
    "id" : "DBA1140",
    "lastKnownWriteTime" : 1437607305,
    "path" : "~/GitHub/Azure-MachineLearning-ClientLibrary-R/maml/R/publish.R",
    "project_path" : "R/publish.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}